-- 1. XỬ LÝ TRIỆT ĐỂ MỌI RÀNG BUỘC (CONSTRAINTS) GÂY LỖI TRÊN BẢNG "songs"
-- Đoạn mã này sẽ tự động tìm và xóa TẤT CẢ các khóa ngoại đang trỏ đến hoặc đi từ bảng songs
DO $$ 
DECLARE 
    r RECORD;
BEGIN 
    -- Tìm và xóa tất cả khóa ngoại liên quan đến bảng songs
    FOR r IN (
        SELECT conname, relname 
        FROM pg_constraint c 
        JOIN pg_class t ON c.conrelid = t.oid 
        WHERE t.relname = 'songs' AND c.contype = 'f'
    ) LOOP
        EXECUTE 'ALTER TABLE public.' || quote_ident(r.relname) || ' DROP CONSTRAINT IF EXISTS ' || quote_ident(r.conname);
    END LOOP;

    -- Tìm và xóa các khóa ngoại từ bảng khác trỏ ĐẾN bảng songs (như liked_songs, play_history...)
    FOR r IN (
        SELECT conname, t.relname 
        FROM pg_constraint c 
        JOIN pg_class t ON c.conrelid = t.oid 
        WHERE c.confrelid = (SELECT oid FROM pg_class WHERE relname = 'songs') AND c.contype = 'f'
    ) LOOP
        EXECUTE 'ALTER TABLE public.' || quote_ident(r.relname) || ' DROP CONSTRAINT IF EXISTS ' || quote_ident(r.conname);
    END LOOP;

    -- Xóa đích danh các constraint "lỳ lợm" bạn vừa gặp
    ALTER TABLE IF EXISTS public.songs DROP CONSTRAINT IF EXISTS "SONGS_album_id_fkey";
    ALTER TABLE IF EXISTS public.songs DROP CONSTRAINT IF EXISTS songs_album_id_fkey;
    ALTER TABLE IF EXISTS public.songs DROP CONSTRAINT IF EXISTS songs_artist_id_fkey;
END $$;

-- 2. CẤU TRÚC BẢNG SONGS CHUẨN (CHO PHÉP NULL HẾT CÁC CỘT RÁC)
CREATE TABLE IF NOT EXISTS public.songs (id TEXT PRIMARY KEY, title TEXT NOT NULL);
ALTER TABLE public.songs ALTER COLUMN id TYPE TEXT USING id::TEXT;
ALTER TABLE public.songs ADD COLUMN IF NOT EXISTS source TEXT DEFAULT 'youtube';
ALTER TABLE public.songs ADD COLUMN IF NOT EXISTS subtitle TEXT;
ALTER TABLE public.songs ADD COLUMN IF NOT EXISTS image_url TEXT;
ALTER TABLE public.songs ADD COLUMN IF NOT EXISTS duration INTEGER DEFAULT 0;
-- Đảm bảo các cột cũ của bạn (nếu có) không bắt buộc NOT NULL
ALTER TABLE public.songs ALTER COLUMN title DROP NOT NULL; -- Đổi sang ALLOW NULL cho chắc
ALTER TABLE public.songs ALTER COLUMN title SET NOT NULL; -- Rồi set lại NOT NULL cho title chính

-- 3. ĐỊNH NGHĨA LẠI CÁC BẢNG LIÊN QUAN VỚI KIỂU TEXT
-- Bảng play_history
CREATE TABLE IF NOT EXISTS public.play_history (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, user_id UUID);
ALTER TABLE public.play_history ADD COLUMN IF NOT EXISTS song_id TEXT;
ALTER TABLE public.play_history ALTER COLUMN song_id TYPE TEXT USING song_id::TEXT;

-- 4. THIẾT LẬP LẠI RÀNG BUỘC CƠ BẢN (CHỈ NHỮNG CÁI CẦN THIẾT)
-- Chỉ giữ lại kịch bản play_history -> songs
ALTER TABLE public.play_history ADD CONSTRAINT play_history_song_id_fkey FOREIGN KEY (song_id) REFERENCES public.songs(id) ON DELETE CASCADE;

-- 5. CHÍNH SÁCH BẢO MẬT (RLS) - RESET TOÀN BỘ
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.songs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.play_history ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow authenticated to upsert songs" ON public.songs;
CREATE POLICY "Allow authenticated to upsert songs" ON public.songs FOR ALL TO authenticated USING (true) WITH CHECK (true);
DROP POLICY IF EXISTS "Allow public to select songs" ON public.songs;
CREATE POLICY "Allow public to select songs" ON public.songs FOR SELECT USING (true);

DROP POLICY IF EXISTS "Allow users to manage own history" ON public.play_history;
CREATE POLICY "Allow users to manage own history" ON public.play_history FOR ALL TO authenticated USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- 6. TRIGGER ĐỒNG BỘ USER
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
CREATE OR REPLACE FUNCTION public.handle_new_user() RETURNS trigger AS $$
BEGIN
  INSERT INTO public.users (id, email, created_at)
  VALUES (new.id, new.email, now())
  ON CONFLICT (id) DO UPDATE SET email = EXCLUDED.email;
  UPDATE public.users SET
    full_name = COALESCE(new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'name', ''),
    avatar_url = COALESCE(new.raw_user_meta_data->>'avatar_url', new.raw_user_meta_data->>'picture', ''),
    username = new.raw_user_meta_data->>'username'
  WHERE id = new.id;
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- 7. TẠO STORAGE BUCKET "avatars"
insert into storage.buckets (id, name, public)
values ('avatars', 'avatars', true)
on conflict (id) do nothing;

create policy "Avatar images are publicly accessible."
  on storage.objects for select
  using ( bucket_id = 'avatars' );

create policy "Anyone can upload an avatar."
  on storage.objects for insert
  with check ( bucket_id = 'avatars' );

create policy "Anyone can update their own avatar."
  on storage.objects for update
  using ( auth.uid() = owner )
  with check ( bucket_id = 'avatars' );
